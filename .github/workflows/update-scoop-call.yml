name: Update Scoop Bucket (Call)

on:
  workflow_call:
    inputs:
      tag:
        description: 'Release tag (e.g., v1.2.3)'
        required: true
        type: string
      source_repo:
        description: 'Source repository (e.g., ropean/MyHosts)'
        required: true
        type: string
      app_name:
        description: 'App name (e.g., myhosts)'
        required: true
        type: string
        default: 'myhosts'
      exe_name:
        description: 'Executable name (e.g., MyHosts.exe)'
        required: true
        type: string
        default: 'MyHosts.exe'
      description:
        description: 'App description'
        required: false
        type: string
        default: 'A simple hosts file editor'
      homepage:
        description: 'Homepage URL'
        required: false
        type: string
        default: ''
      license_identifier:
        description: 'License identifier'
        required: false
        type: string
        default: 'MIT'
      license_url:
        description: 'License URL'
        required: false
        type: string
        default: ''
      shortcut_name:
        description: 'Shortcut display name'
        required: false
        type: string
        default: ''
      shortcut_args:
        description: 'Startup arguments for the shortcut (optional, position 2)'
        required: false
        type: string
        default: ''
      shortcut_icon:
        description: 'Icon file path for the shortcut (optional, position 3)'
        required: false
        type: string
        default: ''
      notes:
        description: 'Additional notes for the package'
        required: false
        type: string
        default: ''
      aliases:
        description: 'Command aliases (comma-separated, e.g., "myapp,ma")'
        required: false
        type: string
        default: ''
    secrets:
      deploy_key:
        description: 'Deploy key for pushing changes to https://github.com/ropean/scoop'
        required: true
      source_repo_token:
        description: 'GitHub App or CI token for accessing source repository (optional, required for private repos)'
        required: false

jobs:
  update-scoop:
    runs-on: ubuntu-latest
    steps:
      - name: Extract version from tag
        id: get_version
        run: |
          VERSION="${{ inputs.tag }}"
          VERSION_NUMBER="${VERSION#v}"
          echo "VERSION_NUMBER=$VERSION_NUMBER" >> $GITHUB_OUTPUT
          echo "VERSION=$VERSION" >> $GITHUB_OUTPUT

      - name: Set default values
        id: defaults
        run: |
          HOMEPAGE="${{ inputs.homepage }}"
          if [ -z "$HOMEPAGE" ]; then
            HOMEPAGE="https://github.com/${{ inputs.source_repo }}"
          fi
          echo "HOMEPAGE=$HOMEPAGE" >> $GITHUB_OUTPUT

          LICENSE_URL="${{ inputs.license_url }}"
          if [ -z "$LICENSE_URL" ]; then
            LICENSE_URL="https://github.com/${{ inputs.source_repo }}/blob/main/LICENSE"
          fi
          echo "LICENSE_URL=$LICENSE_URL" >> $GITHUB_OUTPUT

          SHORTCUT_NAME="${{ inputs.shortcut_name }}"
          if [ -z "$SHORTCUT_NAME" ]; then
            SHORTCUT_NAME="${{ inputs.app_name }}"
          fi
          echo "SHORTCUT_NAME=$SHORTCUT_NAME" >> $GITHUB_OUTPUT

      - name: Download release asset
        run: |
          # Download release asset (works for both public and private repos)
          ASSET_URL="https://github.com/${{ inputs.source_repo }}/releases/download/${{ steps.get_version.outputs.VERSION }}/${{ inputs.exe_name }}"

          # Always use token authentication (empty token is ignored for public repos)
          curl -H "Authorization: token ${{ secrets.source_repo_token }}" \
               -H "Accept: application/octet-stream" \
               -L -o "${{ inputs.exe_name }}" "$ASSET_URL"

          echo "DOWNLOAD_URL=$ASSET_URL" >> $GITHUB_ENV

      - name: Calculate hash
        id: get_hash
        run: |
          HASH=$(sha256sum "${{ inputs.exe_name }}" | cut -d' ' -f1)
          echo "HASH=$HASH" >> $GITHUB_OUTPUT

      - name: Setup Deploy Key for Target Repository
        run: |
          # Create SSH directory and set permissions
          mkdir -p ~/.ssh
          chmod 700 ~/.ssh

          # Add the deploy key to SSH agent
          echo "${{ secrets.deploy_key }}" > ~/.ssh/deploy_key
          chmod 600 ~/.ssh/deploy_key

          # Start SSH agent and add the key
          eval "$(ssh-agent -s)"
          ssh-add ~/.ssh/deploy_key

          # Add GitHub to known hosts
          ssh-keyscan github.com >> ~/.ssh/known_hosts
          chmod 644 ~/.ssh/known_hosts

      - name: Checkout target repository
        uses: actions/checkout@v4
        with:
          repository: ropean/scoop
          ssh-key: ${{ secrets.deploy_key }}

      - name: Configure Git
        run: |
          git config user.name "github-actions[bot]"
          git config user.email "github-actions[bot]@users.noreply.github.com"

      - name: Backup existing manifest and read current version
        id: backup_manifest
        run: |
          # Ensure bucket directory exists
          mkdir -p bucket

          # Check if manifest already exists
          if [ -f "bucket/${{ inputs.app_name }}.json" ]; then
            echo "Existing manifest found, backing up..."
            
            # Read current version from existing manifest
            CURRENT_VERSION=$(jq -r '.version' "bucket/${{ inputs.app_name }}.json" 2>/dev/null || echo "")
            
            if [ -n "$CURRENT_VERSION" ] && [ "$CURRENT_VERSION" != "null" ]; then
              echo "Current version: $CURRENT_VERSION"
              echo "CURRENT_VERSION=$CURRENT_VERSION" >> $GITHUB_OUTPUT
              
              # Backup the existing manifest with version suffix
              cp "bucket/${{ inputs.app_name }}.json" "bucket/${{ inputs.app_name }}@$CURRENT_VERSION.json"
              echo "Backed up to: bucket/${{ inputs.app_name }}@$CURRENT_VERSION.json"
            else
              echo "Could not read version from existing manifest"
              echo "CURRENT_VERSION=" >> $GITHUB_OUTPUT
            fi
          else
            echo "No existing manifest found"
            echo "CURRENT_VERSION=" >> $GITHUB_OUTPUT
          fi

      - name: Create/Update manifest files
        run: |
          VERSION="${{ steps.get_version.outputs.VERSION_NUMBER }}"
          HASH="${{ steps.get_hash.outputs.HASH }}"

          # Create the JSON manifest
          cat > manifest.json << EOF
          {
            "version": "$VERSION",
            "description": "${{ inputs.description }}",
            "homepage": "${{ steps.defaults.outputs.HOMEPAGE }}",
            "license": { 
              "identifier": "${{ inputs.license_identifier }}", 
              "url": "${{ steps.defaults.outputs.LICENSE_URL }}" 
            },
            "url": "$DOWNLOAD_URL",
            "hash": "$HASH",
            "bin": "${{ inputs.exe_name }}",
            "checkver": {
              "github": "${{ inputs.source_repo }}"
            },
            "autoupdate": {
              "url": "https://github.com/${{ inputs.source_repo }}/releases/download/v\$version/${{ inputs.exe_name }}"
            }
          }
          EOF

          # Add shortcuts if shortcut_name is provided
          # Based on Scoop source code: lib/shortcuts.ps1
          # Scoop ONLY supports 4 positions: [exe, name, args, icon]
          # Position 0: executable path (required)
          # Position 1: shortcut name (required)
          # Position 2: startup arguments (optional)
          # Position 3: icon file path (optional)
          # IMPORTANT: There is NO position 4 for description in Scoop!
          if [ -n "${{ inputs.shortcut_name }}" ]; then
            HAS_ICON="${{ inputs.shortcut_icon }}"
            HAS_ARGS="${{ inputs.shortcut_args }}"
            
            if [ -n "$HAS_ICON" ]; then
              # Has icon - must include args position (even if empty)
              jq --arg exe "${{ inputs.exe_name }}" \
                 --arg name "${{ steps.defaults.outputs.SHORTCUT_NAME }}" \
                 --arg args "$HAS_ARGS" \
                 --arg icon "$HAS_ICON" \
                 '. + {"shortcuts": [[$exe, $name, $args, $icon]]}' \
                 manifest.json > temp.json
            elif [ -n "$HAS_ARGS" ]; then
              # Has args but no icon - 3 positions
              jq --arg exe "${{ inputs.exe_name }}" \
                 --arg name "${{ steps.defaults.outputs.SHORTCUT_NAME }}" \
                 --arg args "$HAS_ARGS" \
                 '. + {"shortcuts": [[$exe, $name, $args]]}' \
                 manifest.json > temp.json
            else
              # Only exe and name - 2 positions (most common for GUI apps)
              jq --arg exe "${{ inputs.exe_name }}" \
                 --arg name "${{ steps.defaults.outputs.SHORTCUT_NAME }}" \
                 '. + {"shortcuts": [[$exe, $name]]}' \
                 manifest.json > temp.json
            fi
            mv temp.json manifest.json
          fi

          # Add notes if provided
          if [ -n "${{ inputs.notes }}" ]; then
            jq --arg notes "${{ inputs.notes }}" '. + {"notes": $notes}' manifest.json > temp.json
            mv temp.json manifest.json
          fi

          # Add aliases if provided
          # Scoop bin format for aliases: [["exe", "alias1"], ["exe", "alias2"]]
          if [ -n "${{ inputs.aliases }}" ]; then
            # Convert comma-separated string to array of alias pairs
            ALIASES_INPUT="${{ inputs.aliases }}"
            # First create the app_name alias, then custom aliases
            BIN_ARRAY="[[\"${{ inputs.exe_name }}\", \"${{ inputs.app_name }}\"]]"
            
            # Add custom aliases
            for alias in $(echo "$ALIASES_INPUT" | sed 's/[[:space:]]//g' | tr ',' '\n'); do
              if [ -n "$alias" ]; then
                BIN_ARRAY=$(echo "$BIN_ARRAY" | jq ". += [[\"${{ inputs.exe_name }}\", \"$alias\"]]")
              fi
            done
            
            # Add bin array to manifest
            echo "$BIN_ARRAY" | jq -c '.' > bin_temp.json
            jq --slurpfile bin_array bin_temp.json '. + {"bin": $bin_array[0]}' manifest.json > temp.json
            rm bin_temp.json
            mv temp.json manifest.json
          else
            # Only add app_name as alias
            jq --arg exe "${{ inputs.exe_name }}" \
               --arg app_name "${{ inputs.app_name }}" \
               '. + {"bin": [[$exe, $app_name]]}' manifest.json > temp.json
            mv temp.json manifest.json
          fi

          # Format JSON properly and create the latest manifest
          jq . manifest.json > bucket/${{ inputs.app_name }}.json

          # Show what was created/updated
          echo "Created/Updated:"
          echo "- bucket/${{ inputs.app_name }}.json (latest version $VERSION)"
          if [ -n "${{ steps.backup_manifest.outputs.CURRENT_VERSION }}" ] && [ "${{ steps.backup_manifest.outputs.CURRENT_VERSION }}" != "$VERSION" ]; then
            echo "- bucket/${{ inputs.app_name }}@${{ steps.backup_manifest.outputs.CURRENT_VERSION }}.json (previous version backup)"
          fi

      - name: Commit and push changes
        run: |
          VERSION="${{ steps.get_version.outputs.VERSION_NUMBER }}"

          # Add the latest manifest
          git add bucket/${{ inputs.app_name }}.json

          # Add backup of previous version (if it exists and is different)
          if [ -n "${{ steps.backup_manifest.outputs.CURRENT_VERSION }}" ] && [ "${{ steps.backup_manifest.outputs.CURRENT_VERSION }}" != "$VERSION" ]; then
            git add bucket/${{ inputs.app_name }}@${{ steps.backup_manifest.outputs.CURRENT_VERSION }}.json
          fi

          if git diff --staged --quiet; then
            echo "No changes to commit"
          else
            # Build commit message
            COMMIT_MSG="Update ${{ inputs.app_name }} to version $VERSION

            - Latest: bucket/${{ inputs.app_name }}.json
            - Download URL: $DOWNLOAD_URL
            - SHA256: ${{ steps.get_hash.outputs.HASH }}"
            
            # Add backup info if different from current
            if [ -n "${{ steps.backup_manifest.outputs.CURRENT_VERSION }}" ] && [ "${{ steps.backup_manifest.outputs.CURRENT_VERSION }}" != "$VERSION" ]; then
              COMMIT_MSG="$COMMIT_MSG
            - Previous version backup: bucket/${{ inputs.app_name }}@${{ steps.backup_manifest.outputs.CURRENT_VERSION }}.json"
            fi
            
            COMMIT_MSG="$COMMIT_MSG
            
            Auto-generated by GitHub Actions from https://github.com/${{ inputs.source_repo }}"
            
            git commit -m "$COMMIT_MSG"
            
            # Pull latest changes before pushing to avoid conflicts
            # git pull origin main --rebase
            
            git push origin main
            echo "Successfully updated ${{ inputs.app_name }} to version $VERSION"
          fi
